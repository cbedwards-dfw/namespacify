% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/namespacify.R
\name{namespacify}
\alias{namespacify}
\title{Apply namespace prefixes to one or more files}
\usage{
namespacify(
  packages,
  error.on.collision = TRUE,
  funs.ignore = NULL,
  verbose = TRUE,
  folder = NULL
)
}
\arguments{
\item{packages}{character string of packages to apply namespace prefixes for. In the specified files (below), all functions used by these packages will be the package prefix (e.g. "dplyr::"). To detect likely packages to include, see \code{detect_packages()}.}

\item{error.on.collision}{If two or more packages share a function name (e.g., \{stats\} and \{dplyr\}), should the function error (TRUE) or warn (FALSE)}

\item{funs.ignore}{Character vector of functions to skip when adding namespace prefixes as a solution to function collisions. Defaults to NULL.}

\item{verbose}{Print details to console? Defaults to TRUE.}

\item{folder}{Identify the folder or files to apply namespace prefixes to. If Defaults to the "./R/" folder, which is where the R files of an R package live.}
}
\value{
Nothing
}
\description{
Workhorse function -- this can be called to add the appropriate namespace prefixes to all functions
of the specified package(s) (e.g., adding \verb{dplyr::} to \code{mutate()}) for specific files, all R-related files in a folder,
or all R-related files in the "R/" folder (see the \code{folder} argument for details). Users must provide the packages
for which prefixes can be added, but \code{detect_packages()} provides a suggested list by scanning for
\code{library()} and \code{require()} calls in the files to be updated. See Details for notes on
how function collisions are handled.
}
\details{
There is special handling for "function collisions" -- cases when two or more specified
packages have one or more functions with the same name. If \code{error.on.collision} is set to TRUE,
collisions will cause \code{namspacify} to identify collisions, and then stop.
Users can then specify individual functions to ignore with the \code{funs.ignore} argument.
This is the safest approach to ambiguity.

For example, \{dplyr\} and \{stats\} both have a \code{filter()} function. \code{namespacify()}
doesn't know whether to replace \verb{filter(} with \verb{dplyr::filter(} or \verb{stats::filter(}.
For this reason, \code{namespacify()} will error unless a user included "filter" in
the \code{funs.ignore} argument. Then the user can manually add the appropriate prefix within their scripts,
identifying the specific package in each case.

In cases where collisions are common and anticipated, users can set \code{error.on.collision}
to FALSE. In this case, \code{namespacify()} will instead provide a warning, and then in cases
of collisions will use the first relevant package in the \code{packages} argument. This may be useful
when including packages that reexport functions. In that case, two packages
may have identical functions with the same name, and the choice of package doesn't matter; setting \code{error.on.collision} to
FALSE will allow the assignment of a relevant namespace prefix to all functions. (Note that reexporting among
the tidyverse packages is already addressed; see details see details).

Dev note:  The Tidyverse packages frequently re-export functions (e.g., dplyr includes functions from the tibble package).
This means that including multiple tidyverse packages will automatically lead to "function collisions",
even though they are identical versions of the function, so the choice of namespace doesn't matter.
Right now I have a workaround that skips these internal-to-tidyverse collisions -- these within-tidyverse
collisions are not counted as "function collisions" by \code{namespace}. However, my workaround
is janky -- in cases of within-tidyverse collisions it uses the first relevant tidyverse package listed
in the \code{packages} argument.A cleaner solution would be to identify which package is being rexported \emph{from}, and use that.
I could not identify an easy way to do so.
}
\examples{
\dontrun{
namespacify(packages = c("dplyr", "ggplot2", "purrr", "tidyr",
"DBI", "readr", "stringr", "tidyselect"))
}
}
